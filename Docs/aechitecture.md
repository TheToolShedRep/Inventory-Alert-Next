# Inventory Alert System — Architecture Overview

## Overview

The Inventory Alert System is a low-cost, ledger-based inventory management system designed for food-service operations.

It uses:

- **Google Sheets** as the data ledger (database)
- **Next.js API routes** as the application logic layer
- **Internal API keys** for secure automation
- **Scheduled jobs (cron)** for automated checks and email alerts

The system is intentionally designed to operate with:

- No traditional database
- No recurring infrastructure costs
- Fully deterministic logic
- Clear separation between data and computation

---

# System Philosophy

The system follows a simple architectural model:

> **Google Sheets = Ledger (Source of Truth)**
> **Application Code = Logic Engine**
> **Computed Sheets = Outputs**
> **Actions = Append-Only State Layer**

This structure keeps the system transparent, low-cost, and scalable.

---

# High-Level Flow

```
Staff Inputs / Toast Sales
            ↓
Append to Ledger Tabs (Sheets)
            ↓
Inventory Math + Reorder Check
            ↓
Shopping_List (computed output)
            ↓
Merge Manual Lane + Apply State Rules
            ↓
Shopping List API
            ↓
Email + Dashboard View
```

---

# Data Architecture (Google Sheets)

Each sheet tab serves a specific purpose.

---

## 1. Source-of-Truth Ledgers (Append-Only)

These tabs should never be overwritten — only appended.

### Purchases

Records received inventory.

- When items are bought or delivered.
- Increases inventory.

### Adjustments

Manual corrections to inventory.

- Used for breakage, spoilage, or correction.
- Can increase or decrease inventory.

### Sales_Daily

Imported from POS (e.g., Toast).

- Tracks items sold.
- Drives inventory usage calculations.

### Prep / Recipes

Maps menu items to ingredient usage.

- Used to subtract ingredients from inventory when sales occur.

### Shopping_Actions

State layer for shopping list.

- Records `purchased`, `dismissed`, `snoozed`, `undo`.
- Used to hide or restore items on the list.

### Reorder_Email_Log

Prevents duplicate email sends.

- Stores send timestamps.
- Enforces cooldown rules.
- Prevents multiple sends per day.

---

## 2. Reference Data

### Catalog (Product Metadata)

This is the master product list.

It includes:

```
upc
product_name
brand
size_unit
google_category_id
google_category_name
default_location
preferred_vendor
par_level
active
last_seen
note
purchase_unit
base_unit
unit_per_purchase_unit
reorder_point
```

The Catalog is the **single source of truth for product metadata**.

It defines:

- Reorder thresholds
- Units of measure
- Vendor information
- Storage locations

---

## 3. Computed Output Tabs

These tabs are generated by system logic and can be overwritten safely.

### Inventory Math Outputs

Calculated on-hand values based on:

- Purchases
- Sales
- Adjustments

### Shopping_List

Generated by the reorder-check process.

This tab contains only items that:

- Are below reorder_point
- Need to be ordered

It is intentionally overwriteable.

---

## 4. Manual Lane (Safety Layer)

### Shopping_Manual

Used for:

- Testing
- Calibration
- Manual additions

This sheet allows staff to add items that should not be overwritten by automated jobs.

The system merges:

```
Shopping_List (computed)
+
Shopping_Manual (manual lane)
```

before returning results to the API.

---

# API Architecture

All logic runs through Next.js API routes.

---

## Shopping List Endpoint

### `GET /api/shopping-list`

This endpoint:

1. Reads `Shopping_List`
2. Reads `Shopping_Manual`
3. Merges rows (dedupe by UPC)
4. Enriches missing metadata from Catalog
5. Applies hide rules from `Shopping_Actions`
6. Sorts results
7. Returns final list

This is the **single source of truth for what users see**.

---

## Reorder Check

### `GET /api/inventory/reorder-check` (internal key required)

This job:

1. Reads inventory math outputs
2. Compares against Catalog reorder_point / par_level
3. Writes results into `Shopping_List`

This process overwrites the computed sheet.

---

## Reorder Email

### `GET /api/inventory/reorder-email` (internal key required)

This job:

1. Calls `getShoppingList()`
2. Sends email to subscribers
3. Logs send to `Reorder_Email_Log`
4. Enforces:
   - Once-per-day rule
   - Cooldown period
   - Optional force override

Because it uses the same function as the API, email output always matches the dashboard.

---

# State Layer Logic

The system uses an append-only state model.

When a user clicks:

- Purchased
- Dismissed
- Snoozed
- Undo

The system appends a row to `Shopping_Actions`.

During list generation:

- The latest action per UPC (for today) determines visibility.
- Hidden items are filtered out.
- `undo` restores them.

This prevents destructive updates and maintains historical traceability.

---

# Security Model

The system uses two protection layers:

### Clerk Authentication

Protects dashboard routes and public UI.

### Internal API Key

Protects automated endpoints such as:

- Reorder check
- Email sending
- Inventory adjustments
- POS sync

This allows:

- Cron jobs
- CLI testing
- Server-to-server calls

without requiring user sessions.

---

# Key Design Principles

### 1. Ledger-First Design

All changes append to Sheets.
No destructive writes.

### 2. Deterministic Computation

Computed tabs can be rebuilt from ledger data at any time.

### 3. Separation of Concerns

- Catalog = metadata
- Purchases/Sales = movement
- Computed sheets = output
- Actions = visibility state

### 4. Low-Cost Infrastructure

- No database
- No paid background workers
- No persistent servers
- Fully compatible with free tiers

---

# Mental Model (One Sentence)

> Inputs append to ledgers → Jobs compute outputs → API merges state → Users view final list → Actions append visibility rules.

---

# Scalability Path

This architecture allows future upgrades without rewriting the system:

- Replace Google Sheets with a database (if needed)
- Add POS integrations
- Add vendor cart APIs
- Add forecasting logic
- Add analytics dashboards

The logic layer already supports expansion.

---

# Conclusion

This system is not drifting.

It is structured as:

- Ledger-backed
- Deterministic
- State-driven
- Overwrite-safe
- Low-cost
- Scalable

It is intentionally designed for operational clarity rather than complexity.

---
